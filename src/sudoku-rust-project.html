<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Rust Sudoku Solver - Owen Jones</title>
    <link rel="stylesheet" href="./styles/styles.css">
</head>
<body>
    <div class="container">
        <header>
            <a href="/" class="logo">Owen Jones</a>
            <nav>
                <a href="/">Home</a>
                <a href="/about">About</a>
                <a href="/projects">Projects</a>
                <a href="/contact">Contact</a>
            </nav>
        </header>

        <main>
            <article class="project-article">
                <div class="project-header-large">
                    <div class="header-content">
                        <h1>Rust Sudoku Solver</h1>
                        <div class="project-meta">
                            <span class="status-badge complete">Complete</span>
                            <div class="tech-stack">
                                <span class="tech-tag">Rust</span>
                                <span class="tech-tag">SIMD</span>
                                <span class="tech-tag">Multi-threading</span>
                                <span class="tech-tag">API Integration</span>
                            </div>
                        </div>
                    </div>
                </div>

                <section class="project-section">
                    <h2>Project Overview</h2>
                    <p>A high-performance, multi-threaded Sudoku solver implementation in Rust that combines advanced optimization techniques with modern API integration. The project showcases Rust's capabilities in systems programming while delivering exceptional performance for puzzle solving.</p>
                </section>

                <section class="project-section">
                    <h2>Project Background</h2>
                    <p>This project emerged from a combination of personal interests and technical exploration. As an avid Sudoku enthusiast, I was inspired by the YouTube channel "Coding with John" and his excellent tutorial on building a Java-based Sudoku solver. The project builds upon my previous experience with a Go-based Sudoku solver, incorporating lessons learned while leveraging Rust's unique capabilities for systems programming and performance optimization.</p>
                    
                    <div class="architecture-component">
                        <h3>Inspiration Sources</h3>
                        <ul class="feature-list">
                            <li>Coding with John's Java Sudoku solver tutorial and implementation approach</li>
                            <li>Previous experience developing a Sudoku solver in Go</li>
                            <li>Long-time Sudoku enthusiast</li>
                            <li>Desire to explore Rust's capabilities for high-performance computing</li>
                        </ul>
                    </div>

                    <div class="architecture-component">
                        <h3>Key Improvements</h3>
                        <ul class="feature-list">
                            <li>Enhanced performance through SIMD acceleration</li>
                            <li>More sophisticated multi-threading implementation</li>
                            <li>Addition of API integration for puzzle generation</li>
                            <li>Advanced caching mechanisms</li>
                            <li>Comprehensive benchmarking system</li>
                        </ul>
                    </div>
                </section>

                <section class="project-section">
                    <h2>Performance Metrics</h2>
                    <div class="metrics-grid">
                        <div class="metric-card">
                            <span class="metric-value">14.53ms</span>
                            <span class="metric-label">Average Solve Time</span>
                            <span class="metric-description">Across all difficulty levels</span>
                        </div>
                        <div class="metric-card">
                            <span class="metric-value">100%</span>
                            <span class="metric-label">Success Rate</span>
                            <span class="metric-description">Perfect solve rate across 100 puzzles</span>
                        </div>
                        <div class="metric-card">
                            <span class="metric-value">6x</span>
                            <span class="metric-label">SIMD Speedup</span>
                            <span class="metric-description">Solution validation acceleration</span>
                        </div>
                    </div>
                </section>

                <section class="project-section">
                    <h2>Project Status</h2>
                    <div class="status-summary">
                        <p>This project has reached its successful completion, achieving all initial objectives and performance targets. The implementation demonstrates production-grade quality with:</p>
                        <ul class="feature-list">
                            <li>Comprehensive test coverage (98.7%)</li>
                            <li>Production-ready error handling and logging</li>
                            <li>Thorough documentation and examples</li>
                            <li>Optimized performance across various hardware configurations</li>
                            <li>Battle-tested in real-world applications</li>
                        </ul>
                        <p>While the project is considered complete and stable, the codebase remains well-maintained and serves as a reference implementation for high-performance Rust development. The repository is archived but remains available for study and reference.</p>
                    </div>
                </section>

                <section class="project-section">
                    <h2>Core Features</h2>
                    <div class="architecture-component">
                        <h3>Solver Engine</h3>
                        <ul class="feature-list">
                            <li>Multi-threaded solving with Rayon and adaptive work stealing</li>
                            <li>SIMD-accelerated solution validation with AVX2/SSE4.2 support</li>
                            <li>Advanced candidate tracking with bitset-based elimination</li>
                            <li>Optimized cell selection with minimum remaining values (MRV)</li>
                            <li>Multiple solution detection with early termination</li>
                            <li>Hidden Singles and Naked Pairs solving techniques</li>
                        </ul>
                    </div>

                    <div class="architecture-component">
                        <h3>Generator Module</h3>
                        <ul class="feature-list">
                            <li>Symmetrical puzzle generation with difficulty control</li>
                            <li>Unique solution guarantee through constraint propagation</li>
                            <li>Difficulty rating system based on solving techniques required</li>
                            <li>Pattern-based puzzle templates for consistent generation</li>
                            <li>Multi-threaded generation with puzzle validation</li>
                        </ul>
                    </div>

                    <div class="architecture-component">
                        <h3>Performance Optimization</h3>
                        <ul class="feature-list">
                            <li>Zero-copy board state management with arena allocation</li>
                            <li>Thread-local storage with work stealing scheduler</li>
                            <li>Lock-free concurrent solving with atomic operations</li>
                            <li>SIMD-aligned board representation for vectorized operations</li>
                            <li>Dynamic parallelization based on puzzle complexity</li>
                        </ul>
                    </div>
                </section>

                <section class="project-section">
                    <h2>Benchmark Results</h2>
                    <div class="metrics-grid">
                        <div class="metric-card">
                            <span class="metric-value">98.32Âµs</span>
                            <span class="metric-label">Minimum Solve Time</span>
                        </div>
                        <div class="metric-card">
                            <span class="metric-value">425.18ms</span>
                            <span class="metric-label">Maximum Solve Time</span>
                        </div>
                        <div class="metric-card">
                            <span class="metric-value">35.64s</span>
                            <span class="metric-label">Total Benchmark Duration</span>
                            <span class="metric-description">100 puzzles</span>
                        </div>
                    </div>

                    <div class="architecture-component">
                        <h3>Difficulty Distribution</h3>
                        <ul class="feature-list">
                            <li>Easy: 15% of puzzles</li>
                            <li>Medium: 55% of puzzles</li>
                            <li>Hard: 30% of puzzles</li>
                            <li>Unique Solutions: 100%</li>
                            <li>Average Generation Time: 142ms</li>
                        </ul>
                    </div>
                </section>

                <section class="project-section">
                    <h2>Technical Implementation</h2>
                    
                    <div class="code-examples">
                        <div class="code-snippet">
                            <h3>SIMD-Optimized Board Validation</h3>
                            <pre><code>pub struct SimdValidator;

impl SimdValidator {
    /// Validates a solution using SIMD operations where available
    pub fn validate_solution(board: &Board) -> bool {
        if is_x86_feature_detected!("avx2") {
            unsafe {
                let simd_board = SimdBoard::from_board(board);
                // Process multiple rows simultaneously with AVX2
                for chunk in (0..9).step_by(3) {
                    if !simd_board.validate_multiple_rows_avx2(chunk, 
                        chunk + 3.min(9 - chunk)) {
                        return false;
                    }
                }
                true
            }
        } else if is_x86_feature_detected!("sse4.2") {
            unsafe {
                // SSE4.2 fallback implementation
                Self::validate_solution_sse42(board)
            }
        } else {
            Self::validate_solution_fallback(board)
        }
    }
}</code></pre>
                        </div>

                        <div class="code-snippet">
                            <h3>Advanced Solving Strategy</h3>
                            <pre><code>pub fn solve(&mut self) -> Result<Vec<Vec<i32>>> {
    // Apply advanced solving techniques first
    if self.apply_hidden_singles() || self.apply_naked_pairs() {
        return self.solve(); // Recurse with new information
    }

    let empty_cells = self.find_empty_cells_mrv();
    if empty_cells.is_empty() {
        if !SimdValidator::validate_solution(&self.board) {
            return Err(SudokuError::InvalidBoard);
        }
        return Ok(self.board.to_vec());
    }

    // Parallel processing with work stealing
    let (sender, receiver) = crossbeam_channel::bounded(empty_cells.len());
    empty_cells.into_par_iter()
        .for_each_with(sender, |s, (row, col)| {
            let candidates = self.get_candidates(row, col);
            for &num in candidates.iter() {
                if let Ok(solution) = self.try_solve_with_value(row, col, num) {
                    s.send(solution).unwrap_or_default();
                    break;
                }
            }
        });

    // Collect first valid solution
    receiver.iter().next()
        .ok_or(SudokuError::NoSolution)
}</code></pre>
                        </div>

                        <div class="code-snippet">
                            <h3>Puzzle Generation</h3>
                            <pre><code>pub struct Generator {
    rng: ThreadRng,
    solver: Solver,
    difficulty_evaluator: DifficultyEvaluator,
}

impl Generator {
    pub fn generate_with_difficulty(
        &mut self, 
        difficulty: Difficulty,
        symmetry: bool,
    ) -> Result<Board> {
        let mut attempts = 0;
        loop {
            let board = self.generate_base_board(symmetry)?;
            let holes = self.calculate_holes(difficulty);
            
            let puzzle = self.remove_numbers(board, holes, symmetry);
            if self.validate_unique_solution(&puzzle) {
                let actual_difficulty = 
                    self.difficulty_evaluator.evaluate(&puzzle);
                if actual_difficulty == difficulty {
                    return Ok(puzzle);
                }
            }
            
            attempts += 1;
            if attempts > MAX_ATTEMPTS {
                return Err(GeneratorError::DifficultyNotAchieved);
            }
        }
    }
}</code></pre>
                        </div>
                    </div>
                </section>

                <div class="project-links">
                    <a href="https://github.com/objones25/sudoku_rust" class="github-link" target="_blank">View on GitHub â</a>
                </div>
            </article>
        </main>

        <footer>
            Â© 2024 Owen Jones. All rights reserved.
        </footer>
    </div>
    <script type="module" src="./js/script.js"></script></script>
</body>
</html> 